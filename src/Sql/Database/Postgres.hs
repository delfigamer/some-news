{-# LANGUAGE FlexibleInstances #-}

module Sql.Database.Postgres
    ( withPostgres
    ) where

import Control.Exception
import Control.Monad
import Data.ByteString as BS
import Data.IORef
import Data.Int
import Data.List
import Data.String
import qualified Data.Text as Text
import qualified Data.Text.Encoding as Text
import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromField
import Database.PostgreSQL.Simple.FromRow
import Database.PostgreSQL.Simple.ToField
import Database.PostgreSQL.Simple.ToRow
import Database.PostgreSQL.Simple.Types
import qualified Logger
import qualified Sql.Database as Db
import qualified Sql.Query as Q
import Tuple

withPostgres :: String -> Logger.Handle -> (Db.Handle -> IO r) -> IO r
withPostgres conf logger body = do
    bracket
        (Logger.info logger "Postgres: open connection" >> connectPostgreSQL (Text.encodeUtf8 (Text.pack conf)))
        (\conn -> Logger.info logger "Postgres: close connection" >> close conn)
        (\conn -> do
            body $ Db.Handle
                { Db.queryMaybe = postgresQueryMaybe logger conn
                , Db.withTransaction = postgresWithTransaction logger conn
                })

postgresQueryMaybe :: Logger.Handle -> Connection -> Q.Query result -> IO (Maybe result)
postgresQueryMaybe logger conn queryData = do
    let queryText = Db.renderQueryTemplate renderConstranits queryData
    Logger.debug logger $ "Postgres: " <> Text.pack (show queryData)
    Logger.info logger $ "Postgres: " <> Text.pack queryText
    let sqlQuery = fromString queryText :: Query
    eresult <- try $ case queryData of
        Q.CreateTable {} -> do
            _ <- execute_ conn sqlQuery
            return ()
        Q.AddTableColumn {} -> do
            _ <- execute_ conn sqlQuery
            return ()
        Q.DropTable {} -> do
            _ <- execute_ conn sqlQuery
            return ()
        Q.Select _ fields mcond _ _ -> Db.withConditionValues mcond $ queryWith (valueParser fields) conn sqlQuery
        Q.Insert _ _ rows -> do
            _ <- executeMany conn sqlQuery rows
            return ()
        Q.InsertReturning _ _ values rets -> do
            [r] <- queryWith (valueParser rets) conn sqlQuery values
            return r
        Q.Update _ _ values mcond -> Db.withConditionValues mcond $ \condvals -> do
            _ <- execute conn sqlQuery $ joinTuple values condvals
            return ()
        Q.Delete _ mcond -> Db.withConditionValues mcond $ \condvals -> do
            _ <- execute conn sqlQuery condvals
            return ()
    case eresult of
        Left err -> do
            Logger.warn logger $ "Postgres: " <> Text.pack (displayException (err :: SomeException))
            return Nothing
        Right result -> return $ Just result

postgresWithTransaction :: Logger.Handle -> Connection -> IO r -> IO r
postgresWithTransaction logger conn act = do
    Logger.info logger $ "Postgres: BEGIN TRANSACTION"
    r <- withTransaction conn act
    Logger.info logger $ "Postgres: COMMIT TRANSACTION"
    return r

renderConstranits :: [Q.ColumnConstraint a] -> String
renderConstranits [] = ""
renderConstranits (Q.CPrimaryKey:cs) = " PRIMARY KEY" ++ renderConstranits cs
renderConstranits (Q.CIntegerId:cs) = " PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY" ++ renderConstranits cs

valueParser :: TupleT Q.Field ts -> RowParser (TupleT Q.Value ts)
valueParser fields = Q.decode fields <$> primParser (Q.primFields fields)

primParser :: TupleT Q.PrimField ts -> RowParser (TupleT Q.PrimValue ts)
primParser E = return E
primParser (Q.FInt _ :* fs) = (:*) <$> field <*> primParser fs
primParser (Q.FFloat _ :* fs) = (:*) <$> field <*> primParser fs
primParser (Q.FText _ :* fs) = (:*) <$> field <*> primParser fs
primParser (Q.FBlob _ :* fs) = (:*) <$> field <*> primParser fs

instance FromField (Q.PrimValue Int64) where
    fromField f b = (Q.VInt <$> fromField f b) `mplus` return Q.VNull

instance FromField (Q.PrimValue Double) where
    fromField f b = (Q.VFloat <$> fromField f b) `mplus` return Q.VNull

instance FromField (Q.PrimValue Text.Text) where
    fromField f b = (Q.VText <$> fromField f b) `mplus` return Q.VNull

instance FromField (Q.PrimValue BS.ByteString) where
    fromField f b = (Q.VBlob <$> fromField f b) `mplus` return Q.VNull

instance ToRow (TupleT Q.Value ts) where
    toRow = mapTuple toField . Q.encode

instance ToField (Q.PrimValue a) where
    toField (Q.VInt x) = toField x
    toField (Q.VFloat x) = toField x
    toField (Q.VText x) = toField x
    toField (Q.VBlob x) = toField x
    toField Q.VNull = toField Null
